---
title: "lfq_pipeline"
author: "Dain Brademan"
date: "2024-01-30"
output: html_document
---

## R Markdown

This is an R Markdown document. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see <http://rmarkdown.rstudio.com>.

When you click the **Knit** button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document.

# Installing / Loading Required R Libraries

When I'm working on a script from the ground up, the first thing I like to do is install (if not already installed) & load all the libraries that I'm planning on using before I even start thinking about loading and manipulating any data.

### Installing CRAN Packages

Libraries only need to be installed once. After that, they're saved to your computer and you can view them under the **Packages** tab in the bottom right panel on your screen. How do you tell which libraries/packages you need to install? I usually just run the load statements below, and R will tell me if I don't have a package installed

The packages used in this code come from two different repositories, $\underline{C}omprehensive\space\underline{R}\space\underline{A}rchive\space\underline{N}etwork$ (CRAN) and BioConductor. They're installed differently.

CRAN packages can be installed several different ways. The first way is demonstrated in the code chunk below. Alternatively, you can click to the **Packages** tab over on the bottom right of the screen. You'll find an **Install** and **Update** button there that you can use to browse for packages

```{r}
# Don't need run this every time. 
# Only if you need to install a package.
# Just replace the Package in the parentheses with whatever you need installed
# install.packages(R.utils) # Commented out for convenience
```

### Installing BioConductR Packages

BioConductor has its own package manager. Before you can install anything from it, you first need to install the BioConductor manager from CRAN.

```{r}
# install.packages("BiocManager")
```

Then you can install all the BioConductor packages you want! Note, you may be prompted in the console window (bottom left) if you want to update packages. It's generally a good idea. Sometimes a package refuses to update. If that happens, close out of all your R tabs, clear your workspace, and try again. Sometimes incompatible packages can clash and cause really weird errors that are tough to troubleshoot, so I'd recommend keeping things as updated as possible.

```{r}
# Install a specific version of BioConductor core packages
# BiocManager::install(version = "3.18)

# Install latest version of BioConductor core packages
# BiocManager::install()

```

Some BioConductor packages don't install with the core distribution. Do install these add-ons, you can specifically request these packages be installed

```{r}
# Install a set of specific non-core package. Format: c("Package1", "Package2", etc....)
# BiocManager::install(c("MSstats"))
```

### Load Packages

Now that in theory everything is installed. Let's load our packages. If you get any errors regarding **Package not found**, just go back and install it! A general rule is the fully lowercase libraries are from CRAN and the CamelCase libraries are from BioConductor

```{r}
# Load Packages
library(MSstats)
library(dplyr)
library(R.utils) # Actually a cran package
library(dplyr)
library(svglite)
library (data.table)
# library (ComplexHeatmap) # not needed in this code
library (circlize)
library (ggplot2)
rotate.x.axis.text <- theme(axis.text.x = element_text(angle = 90,vjust = 0.5, hjust=1))
library (magrittr)
library (pbapply)
library(ggrepel)

# Krogan Lab Utility Functions
utils <- "../../bp_utils/"
source(paste0(utils,"ManageScriptData.R"))
WriteSessionInfo()
WriteInstalledPackages()

# Package versions
# MSstats version 4.10.0
# MSstatsTMT version 2.10.0
# MSstatsPTM version 2.4.1
```

# Pipeline Parameters
Enter in values specific to your dataset in this block and run all blocks of code sequentially.
```{r}
# Data Type
# SP - Spectronaut
# MQ - MaxQuant
export.type <- "MQ" 

dataType <- "Abundance"
dataName <- "AM_Beadtest01"

# File paths to your mass spec data in either MaxQuant or Spectronaut format
if (export.type == "SP") {
  # Spectronaut specific parameters
  spectronaut.lfq.report <- "../example_data/example_data_spectronaut.tsv"
} else if (export.type == "MQ") {
  maxquant.evidence <- "../example_data/example_data_MQ_evidence.txt"
  maxquant.proteingroups <- "../example_data/example_data_MQ_proteinGroups.txt"
  maxquant.annotations <- "../example_data/example_data_MQ_annotations.csv"
} else {
  stop("Non-supported data type. Make sure data type is SP or MQ, otherwise pipeline will break.")
}

# Names of all possible contrasts will be generated from Condition names (formatted "ConditionName1-ConditionName2")
  ## Example: regexContrasts <- c("Fsk-DMSO", "H2O2_Fsk-Fsk", "H2O2-DMSO", "H2O2_Fsk-H2O2")
  ## This list should be strings that match your exact condition names that you entered in Spectronaut. 
  ## You can also use RegEex terms if you know what you're doing, but I find it more exact to use full condition names to avoid accidental     RegEx matches

global.regexContrasts <- c("ctrl_40-0min_40", "ctrl_40-5min_40", "0min_40-5min_40",
                    "ctrl_50-0min_50", "ctrl_50-5min_50", "0min_50-5min_50",
                    "ctrl_60-0min_60", "ctrl_60-5min_60", "0min_60-5min_60",
                    "ctrl_70-0min_70", "ctrl_70-5min_70", "0min_70-5min_70",
                    "ctrl_80-0min_80", "ctrl_80-5min_80", "0min_80-5min_80")

experiment.regexContrasts <- c("0min_40-5min_40", "0min_50-5min_50", "0min_60-5min_60", "0min_70-5min_70", "0min_80-5min_80")

# Sometimes you want to remove certain runs because they're bad, or before data normalization. 
# You can also do this at the condition level for ease, but you'll need to modify the code in the post-normalization section to do this
# Specify the runs here. 
runs.to.remove <- c("TT000243_AM04-01","TT000244_AM04-02","TT000245_AM04-03","TT000246_AM04-04","TT000247_AM04-05","TT000254_AM04-12","TT000255_AM04-13","TT000256_AM04-14","TT000257_AM04-15","TT000258_AM04-16")
```

# Import Data

```{r}

# Spectronaut specific data files
if (export.type == "SP") {
  spectronaut.lfq.report <- fread(spectronaut.lfq.report)
  
# MaxQuant specific data files
} else if (export.type == "MQ") {
  maxquant.evidence <- fread(maxquant.evidence)
  maxquant.proteingroups <- fread(maxquant.proteingroups)
  maxquant.annotations <- fread(maxquant.annotations)
}
```

### Clean data
It's recommended to include commonly observed contaminant proteins when processing your proteomic datasets. However, Spectronaut does not remove these entries for you. Fortunately, all contaminant protein accessions are prepended with the text **Cont\_** so we can go through each row in our dataset and toss that data ourselves.
```{r}
if (export.type == "SP") {
  # remove all contaminant proteins.
  substring_to_remove <- "Cont_"
  
  # Identify rows containing the contaminant substring
  rows_to_remove <- grep(substring_to_remove, spectronaut.lfq.report$PG.ProteinAccessions)
  
  # Remove rows using the above vector of row indices
  spectronaut.lfq.report <- spectronaut.lfq.report[-rows_to_remove, ]
  
  rm(rows_to_remove, substring_to_remove)
}
```

### Make protein metadata linker table

During data processing via msStats most of the metadata we'd like to include for visualization or functional enrichment analysis is discarded. I find it useful to create a linker table early on containing all the metadata I want to crossmap back in based on a unique identifier. The best one I've found is the Uniprot accession ID column AKA **PG.ProteinAccession**.

``` {r}

# Spectronaut specific protein linker table
if (export.type == "SP") {
  
  # scrape a linker table for Uniprot IDs and Protein Names for later visualization
  proteinNameCrossLookup <- subset(spectronaut.lfq.report, select = c(PG.ProteinAccessions, PG.ProteinNames))
  
# MaxQuant specific protein linker table
} else if (export.type == "MQ") {
  
  # scrape a linker table for Uniprot IDs and Protein Names for later visualization
  proteinNameCrossLookup <- subset(maxquant.proteingroups, select = c(`Protein IDs`, `Gene names`))
}

# rename columns for easy merging later
colnames(proteinNameCrossLookup) <- c("Protein", "ProteinName")

# filter to distinct protein IDs. %>% is an operator from the package magrittr which can be used to chain multiple functions together.
proteinNameCrossLookup <- proteinNameCrossLookup %>% distinct(Protein, .keep_all = TRUE)

```


### Reformat data for msStats Data Processing

Most proteomic pipelines by default do not export data in the format that msStat expects for protein grouping and normalization. Fortunately for us, msStats already has a built-in converter function that we can take advantage of with minimal effort. While it's not the worst thing to reformat this data ourselves, work smarter, not harder. 

After this stage, we will no longer need to write special code to handle Spectronaut vs MaxQuant data

``` {r}
if (export.type == "SP") {
  
  # the optional arguments are recommended in the msStats user guide. Feel free to change if you know better.
  global.prepared <- SpectronauttoMSstatsFormat(spectronaut.lfq.report,
                                       filter_with_Qvalue = TRUE, ## same as default
                                       qvalue_cutoff = 0.01, ## same as default
                                       removeProtein_with1Feature = TRUE,
                                       use_log_file = FALSE)
  
  rm(spectronaut.lfq.report)
} else if (export.type == "MQ") {
  
  global.prepared <- MaxQtoMSstatsFormat(maxquant.evidence, 
                                       maxquant.annotations, 
                                       maxquant.proteingroups)
  
  rm(maxquant.evidence, maxquant.annotations, maxquant.proteingroups)
}

```

# Quality Control Plots of the Raw Data

Now is a good time to take a look at the raw data.

```{r}
hist(log2(global.prepared$Intensity), breaks = 100)
```

```{r}
unique_counts <- as.data.table(global.prepared) %>%
  filter(!is.na(Intensity)) %>%
  group_by(Condition) %>%
  summarize(Unique_Peptide_Count = n_distinct(PeptideSequence))

ggplot(unique_counts, aes(x = Condition, y = Unique_Peptide_Count)) +
  geom_bar(stat = "identity", fill = "skyblue", width = 0.5) +
  labs(title = "Unique Transitions / Peptide Sequences per Condition",
       x = "Condition",
       y = "Number of Unique Transitions / Peptide Sequences") +
  geom_vline(xintercept = 5.5, linetype = "dashed", color = "darkgray") +
  geom_vline(xintercept = 10.5, linetype = "dashed", color = "darkgray") +
  rotate.x.axis.text

ggsave("./UniqueTransitionOrPeptideSequencesPerCondition.pdf")
```

```{r}
ggplot (data = global.prepared, aes (x = paste0(Condition, "_", BioReplicate),
                          y = log10(Intensity), 
                          fill = Condition)) + 
  geom_boxplot() +
  rotate.x.axis.text # this is defined in the default template of all my Rmd files

ggsave("FeatureIntensitiesPerSample.svg")
```

# Use MSstats for protein summarization

This is where we summarize peptides (or peptide transitions depending on your data export format) back into protein groups. Depending on your experiment, you're going to want to turn normalization on or off. For your typical APEX experiment, the control condition doesn't have Biotin Phenol meaning biotin enrichment does not occur. We expect an entirely different population of proteins to be enriched for in the BP samples, so its best to not do any sort of normalization at this point.

```{r}
global.proteinSummarization = MSstats::dataProcess(global.prepared,
                               normalization = 'FALSE',				
                               logTrans = 2,				
                               featureSubset = 'highQuality',				
                               summaryMethod="TMP",
                               censoredInt='NA',				
                               MBimpute=TRUE,				
                               maxQuantileforCensored=0.999)
```

```{r}

# Save feature and Protein -level data from MsStats output
fwrite (global.proteinSummarization$FeatureLevelData, ScriptAndDatedFileName(paste(dataName,dataType,"NonNormalized_FeatureLevelData.csv.gz",sep = "_")))
fwrite (global.proteinSummarization$ProteinLevelData, ScriptAndDatedFileName(paste(dataName,dataType,"NonNormalized_ProteinLevelData.csv.gz", sep = "_")))
```

# Plot protein intensities pre-normalization

All of our peptide-level data has now been summarized into protein groups. Let's inspect the intensity distributions of this data. Note: the data process function already log2 transformed this data, so we don't have to ourselves.

```{r}

ggplot (global.proteinSummarization$ProteinLevelData, 
        aes (x = interaction ( SUBJECT, GROUP), y = LogIntensities, fill = GROUP)) + geom_boxplot() + rotate.x.axis.text
ggsave("ProteinIntensities_PreNormalization.svg")

```

```{r}
unique_counts <- global.proteinSummarization$ProteinLevelData %>%
  filter(!is.na(LogIntensities)) %>%
  group_by(GROUP) %>%
  summarize(Unique_Protein_Count = n_distinct(Protein))

ggplot(unique_counts, aes(x = GROUP, y = Unique_Protein_Count)) +
  geom_bar(stat = "identity", fill = "skyblue", width = 0.5) +
  labs(title = "Count of Protein Groups per Condition",
       x = "Condition",
       y = "Number of Protein Groups") +
  geom_vline(xintercept = 5.5, linetype = "dashed", color = "darkgray") +
  geom_vline(xintercept = 10.5, linetype = "dashed", color = "darkgray") +
  rotate.x.axis.text

ggsave("./UniqueProteinGroupsPerCondition.pdf")
```

# Plot average protein CVs per condition

```{r}
proteomics_data <- global.proteinSummarization$ProteinLevelData %>%
  group_by(GROUP, Protein) %>%
  summarize(CV = sd(LogIntensities) / mean(LogIntensities) * 100)

# Plot the distribution of CV for each group
ggplot(proteomics_data, aes(x = GROUP, y = CV)) +
  geom_boxplot() +
  labs(title = "Coefficient of Variation Distribution by Group",
       x = "Please note CV's were calculated in Log2 space, not raw intensities",
       y = "Coefficient of Variation (%)") +
  rotate.x.axis.text

ggsave("./PreNormalization_ProteinCVs.pdf")
```

# Native Carboxylase Enrichment

This is a quality control plot I borrowed from Ben Polacco.If you've normalized your data, it's useful. Without normalization the results are pretty difficult to interpret.

*APEX works by labeling neighboring/interacting proteins with biotin which is then used to purify labeled proteins. There are also proteins that are endogenously biotinylated which will co-purify with the APEX-labeled proteins. Here we look at a subset of these endogenous biotin proteins, and we inspect their post-normalization background levels, which are inversely related to the labeling-efficiency of APEX. More background after normalization implies there is less APEX-labeled signal.*

If you see your control conditions at higher abundance compared to the rest of your samples, great, APEX worked!

```{r}

biotin.carboxylases.up <- c("O00763","P05165","P11498","Q13085","Q96RQ3")

test <- as.data.table(global.proteinSummarization$ProteinLevelData)
test <- test[grepl(paste(biotin.carboxylases.up, collapse = "|"), test$Protein), ]
#test <- test[test$Protein %in% biotin.carboxylases.up, ]
#ggplot(test[Protein %in% biotin.carboxylases.up], aes (x = interaction ( SUBJECT, GROUP ), y = LogIntensities, color = Protein)) + geom_line(aes(group = Protein)) + geom_point(aes(shape = as.factor(SUBJECT))) +  rotate.x.axis.text

# Plotting code
ggplot(test, aes(x = Protein, y = LogIntensities, fill = GROUP)) +
  stat_summary(
    fun.data = mean_sdl,
    fun.args = list(mult = 1),
    geom = "bar",
    position = position_dodge(width = 0.8),  # Adjust the width as needed
    width = 0.6  # Adjust the width of bars
  ) +
  stat_summary(
    fun.data = mean_sdl,
    fun.args = list(mult = 1),
    geom = "errorbar",
    position = position_dodge(width = 0.8),
    width = 0.4  # Adjust the width of error bars
  ) +
  labs(title = "Mean Log Intensities with Standard Deviation by GROUP",
       x = "GROUP", y = "Log Intensities") +
  theme_bw()

ggsave("NativeCarboxylases_preNormalization.svg")

rm(biotin.carboxylases.up, test)
```

# Do global pairwise comparisons to check for successful APEX enrichment

Another way you can check for successful APEX enrichment is to make volcano plots comparing protein abundances between non-BP vs BP conditions. What you should see is a mass up-regulation of most proteins. If you don't see that, your enrichment likely didn't work, or you have a ton of background binding. To make these comparisons, we can use the GroupComparison function from msStats. To use this function, you need the output from MSstats::DataProcess, and you also have to build a contrast matrix, essentially a numerical vector indicating what experimental conditions you want to compare.

The first thing I like to do is get the ordered list of experimental conditions from the MsStats output. It makes it easier for me to visualize all the experimental conditions in the study, and I base my contrast matrix around the order of this list. You need to stipulate all the conditions that you DataProcess'd together. You unfortunately can't just subselect a handful.

```{r}
global.orderedConditions <- levels(global.proteinSummarization$ProteinLevelData$GROUP)
cat(global.orderedConditions)
```

Angelina wants a pairwise comparison for all possible conditions. Use Ben Polacco's *makeContrast* function to help build the group comparison matrix without errors. Again, you can do this yourself if you're careful without using this function.

```{r}

source (paste0(utils,"MSstats_V4_Functions.R"))

# makes an MsStats-compatible contrast matrix using the condition comparisons in the parameter block
contrast.matrix <- makeContrast.regEx ( regEx = global.regexContrasts,
                                    mssQ = global.proteinSummarization)

# create time stamped file
resultsFile <- ScriptAndDatedFileName(paste(dataName,dataType,"GroupComparisonResult.csv", sep = "_"))
#optional if not running as job
save ( "global.proteinSummarization", "contrast.matrix", "resultsFile", file = ScriptAndDatedFileName(paste(dataName,dataType, "inputGroupComparison.Rdata", sep = "_")))

# Model-based comparison
# Do pairwise comparison via MSstats using the provide contrast matrix, then select the comparison results

global.pairwiseComparison <- MSstats::groupComparison(contrast.matrix, global.proteinSummarization)$ComparisonResult
global.pairwiseComparison <- merge(global.pairwiseComparison, proteinNameCrossLookup, by = "Protein", all.x = TRUE)

```

# Volcano Plots

Do all the volcano plots for Angelina.

```{r}

# This is essentially a foreach loop. 
# Takes each of the labels of the above pairwise comparison
# Subselects that specific data
# Finally, makes the volcano plot
lapply(global.regexContrasts, function(comparison) {
  
  # define significant proteins
  thisPairwiseComparison <- as.data.table(global.pairwiseComparison %>% filter(Label == comparison))
  
  # Merge human readable protein names in case they're not there.
  
  ## This chunks adds a new column to our pairwise comparison data table
  # For all proteins with |Log2FC| < 1 and pval > 0.05, value is "Not"
  # For proteins with |Log2FC| >= 1 and pval <= 0.05, value is "Up" or "Down" as appropriate
  thisPairwiseComparison[, Significance := "Not"]
  thisPairwiseComparison[pvalue < 0.05 & abs(log2FC) > log2(1.5),
         Significance := ifelse (log2FC > 0, "Up", "Down")]
  
  ## Render volcano plots. Highlight arrestin and adrenoceptor beta 2
  ggplot(thisPairwiseComparison, aes(x = log2FC, y = -log10(pvalue), color = Significance, label = ProteinName)) +
    
    # significance labels and lines
    # vertical lines
    geom_vline(xintercept = c(-log2(1.5), log2(1.5)), linetype = "dashed", color = "darkgray") +
    annotate("text", x = c(-log2(1.5), log2(1.5)), y = 0, label = c("-Log2(1.5)", "Log2(1.5)"), vjust = 1, hjust = 0.5, color = "darkgray") +
    
    # horizontal line
    geom_hline(yintercept = -log10(0.05), linetype = "dashed", color = "darkgray") +
    annotate("text", x = Inf, y = -log10(0.05), label = "p-val=0.05", hjust = 1, color = "darkgray") +
  
    # circles representing proteins
    geom_point() +
    scale_color_manual(values = c(Not = "gray", Down = "blue", Up = "red")) +
    ggrepel::geom_text_repel(data = thisPairwiseComparison[Significance != "Not"], size = 2, max.overlaps = 20) +
    
    # highlight people's favorite protein
    geom_point(data = thisPairwiseComparison[thisPairwiseComparison$ProteinName == "ARRB2;DKFZp686L0365", ],
               aes(x = log2FC, y = -log10(pvalue)), color = "green", size = 3) +
    geom_text_repel(data = thisPairwiseComparison[thisPairwiseComparison$ProteinName == "ARRB2;DKFZp686L0365", ],
                    aes(x = log2FC, y = -log10(pvalue)), label = "ARRB2_HUMAN", color = "green", size = 3, box.padding = 0.5) +
    
    geom_point(data = thisPairwiseComparison[thisPairwiseComparison$ProteinName == "EEA1", ],
               aes(x = log2FC, y = -log10(pvalue)), color = "green", size = 3) +
    geom_text_repel(data = thisPairwiseComparison[thisPairwiseComparison$ProteinName == "EEA1", ],
                    aes(x = log2FC, y = -log10(pvalue)), label = "EEA1_HUMAN", color = "green", size = 3, box.padding = 0.5) +
    theme_bw()
  
  ggsave(paste("./VolcanoPlot", paste(comparison, ".pdf", sep = ""), sep = "_"))
})


```

Great! From these results, we can definitely see that our APEX labeling worked! If we didn't see a bunch of proteins with large Log2 fold change values, we'd know something went wrong with our labeling.

# Now for the actual experimental comparisons

Okay, so we confirmed the APEX labeling worked using our no-BP controls. Now to make the comparisons we're actually interested in, we need to go back to our original dataset, toss out the no-bp controls, then do the pairwise comparisons all over again WITH median normalization enabled this time.

```{r}

experiment.ConditionSubset <- global.prepared[!(global.prepared$Run %in% runs.to.remove), ]

experiment.msstatsResults <- MSstats::dataProcess(experiment.ConditionSubset,
                                                  normalization = "EQUALIZEMEDIANS",
                                                  featureSubset = "highQuality",
                                                  censoredInt="0",
                                                  MBimpute=TRUE,
                                                  maxQuantileforCensored=0.999 )

```

```{r}

# Save feature and Protein -level data from MsStats output
fwrite (experiment.msstatsResults$FeatureLevelData, ScriptAndDatedFileName(paste(dataName,dataType,"Normalized_FeatureLevelData.csv.gz",sep = "_")))
fwrite (experiment.msstatsResults$ProteinLevelData, ScriptAndDatedFileName(paste(dataName,dataType,"Normalized_ProteinLevelData.csv.gz", sep = "_")))
```

# Plot protein intensities pre-normalization

All of our peptide-level data has now been summarized into protein groups. Let's inspect the intensity distributions of this data. Note: the data process function already log2 transformed this data, so we don't have to ourselves.

```{r}

ggplot (experiment.msstatsResults$ProteinLevelData, 
        aes (x = interaction ( SUBJECT, GROUP), y = LogIntensities, fill = GROUP)) + geom_boxplot() + rotate.x.axis.text
ggsave("ProteinIntensities_PostNormalization.svg")

```

```{r}
unique_counts <- experiment.msstatsResults$ProteinLevelData %>%
  filter(!is.na(LogIntensities)) %>%
  group_by(GROUP) %>%
  summarize(Unique_Protein_Count = n_distinct(Protein))

ggplot(unique_counts, aes(x = GROUP, y = Unique_Protein_Count)) +
  geom_bar(stat = "identity", fill = "skyblue", width = 0.5) +
  labs(title = "Count of Protein Groups per Condition",
       x = "Condition",
       y = "Number of Protein Groups") +
  geom_vline(xintercept = 5.5, linetype = "dashed", color = "darkgray") +
  geom_vline(xintercept = 10.5, linetype = "dashed", color = "darkgray") +
  rotate.x.axis.text

ggsave("./UniqueProteinGroupsPerCondition.pdf")
```

# Plot average protein CVs per condition

```{r}
proteomics_data <- experiment.msstatsResults$ProteinLevelData %>%
  group_by(GROUP, Protein) %>%
  summarize(CV = sd(LogIntensities) / mean(LogIntensities) * 100)

# Plot the distribution of CV for each group
ggplot(proteomics_data, aes(x = GROUP, y = CV)) +
  geom_boxplot() +
  labs(title = "Coefficient of Variation Distribution by Group",
       x = "Please note CV's were calculated in Log2 space, not raw intensities",
       y = "Coefficient of Variation (%)") +
  rotate.x.axis.text

ggsave("./PostNormalization_ProteinCVs.pdf")
```

# Native Carboxylase Enrichment

```{r}

biotin.carboxylases.up <- c("O00763","P05165","P11498","Q13085","Q96RQ3")

test <- as.data.table(experiment.msstatsResults$ProteinLevelData)
test <- test[grepl(paste(biotin.carboxylases.up, collapse = "|"), test$Protein), ]

# Plotting code
ggplot(test, aes(x = Protein, y = LogIntensities, fill = GROUP)) +
  stat_summary(
    fun.data = mean_sdl,
    fun.args = list(mult = 1),
    geom = "bar",
    position = position_dodge(width = 0.8),  # Adjust the width as needed
    width = 0.6  # Adjust the width of bars
  ) +
  stat_summary(
    fun.data = mean_sdl,
    fun.args = list(mult = 1),
    geom = "errorbar",
    position = position_dodge(width = 0.8),
    width = 0.4  # Adjust the width of error bars
  ) +
  labs(title = "Mean Log Intensities with Standard Deviation by GROUP",
       x = "GROUP", y = "Log Intensities") +
  theme_bw()

ggsave("NativeCarboxylases_postNormalization.svg")

rm(biotin.carboxylases.up, test)
```

# Do global pairwise comparisons to check for successful APEX enrichment

```{r}
experiment.orderedConditions <- levels(experiment.msstatsResults$ProteinLevelData$GROUP)
cat(global.orderedConditions)

```

We want to do a pairwise comparison for all possible conditions. Use Ben Polacco's *makeContrast* function to help build the group comparison matrix without errors. You can bind your own contrast matrix manually, but the process is very detail oriented and mistakes can be easily made.

```{r}

source (paste0(utils,"MSstats_V4_Functions.R"))

# makes an MsStats-compatible contrast matrix using the condition comparisons in the parameter block
contrast.matrix <- makeContrast.regEx ( regEx = experiment.regexContrasts,
                                    mssQ = experiment.msstatsResults)

# create time stamped file
resultsFile <- ScriptAndDatedFileName(paste(dataName,dataType,"PostNormalization_GroupComparisonResult.csv", sep = "_"))
#optional if not running as job
save ( "experiment.msstatsResults", "contrast.matrix", "resultsFile", file = ScriptAndDatedFileName(paste(dataName,dataType, "postNormalization_inputGroupComparison.Rdata", sep = "_")))

# Model-based comparison
# Do pairwise comparison via MSstats using the provide contrast matrix, then select the comparison results

experiment.pairwiseComparison <- MSstats::groupComparison(contrast.matrix, experiment.msstatsResults)$ComparisonResult
experiment.pairwiseComparison <- merge(experiment.pairwiseComparison, proteinNameCrossLookup, by = "Protein", all.x = TRUE)

```

# Volcano Plots

```{r}

# This is essentially a foreach loop. 
# Takes each of the labels of the above pairwise comparison
# Subselects that specific data
# Finally, makes the volcano plot
lapply(experiment.regexContrasts, function(comparison) {
  
  # define significant proteins
  thisPairwiseComparison <- as.data.table(global.pairwiseComparison %>% filter(Label == comparison))
  
  # Merge human readable protein names in case they're not there.
  
  ## This chunks adds a new column to our pairwise comparison data table
  # For all proteins with |Log2FC| < 1 and pval > 0.05, value is "Not"
  # For proteins with |Log2FC| >= 1 and pval <= 0.05, value is "Up" or "Down" as appropriate
  thisPairwiseComparison[, Significance := "Not"]
  thisPairwiseComparison[pvalue < 0.05 & abs(log2FC) > log2(1.5),
         Significance := ifelse (log2FC > 0, "Up", "Down")]
  
  ## Render volcano plots. Highlight arrestin and adrenoceptor beta 2
  ggplot(thisPairwiseComparison, aes(x = log2FC, y = -log10(pvalue), color = Significance, label = ProteinName)) +
    
    # significance labels and lines
    # vertical lines
    geom_vline(xintercept = c(-log2(1.5), log2(1.5)), linetype = "dashed", color = "darkgray") +
    annotate("text", x = c(-log2(1.5), log2(1.5)), y = 0, label = c("-Log2(1.5)", "Log2(1.5)"), vjust = 1, hjust = 0.5, color = "darkgray") +
    
    # horizontal line
    geom_hline(yintercept = -log10(0.05), linetype = "dashed", color = "darkgray") +
    annotate("text", x = Inf, y = -log10(0.05), label = "p-val=0.05", hjust = 1, color = "darkgray") +
  
    # circles representing proteins
    geom_point() +
    scale_color_manual(values = c(Not = "gray", Down = "blue", Up = "red")) +
    ggrepel::geom_text_repel(data = thisPairwiseComparison[Significance != "Not"], size = 2, max.overlaps = 20) +
    
    # highlight people's favorite protein
    geom_point(data = thisPairwiseComparison[thisPairwiseComparison$ProteinName == "ARRB2;DKFZp686L0365", ],
               aes(x = log2FC, y = -log10(pvalue)), color = "green", size = 3) +
    geom_text_repel(data = thisPairwiseComparison[thisPairwiseComparison$ProteinName == "ARRB2;DKFZp686L0365", ],
                    aes(x = log2FC, y = -log10(pvalue)), label = "ARRB2_HUMAN", color = "green", size = 3, box.padding = 0.5) +
    
    geom_point(data = thisPairwiseComparison[thisPairwiseComparison$ProteinName == "EEA1", ],
               aes(x = log2FC, y = -log10(pvalue)), color = "green", size = 3) +
    geom_text_repel(data = thisPairwiseComparison[thisPairwiseComparison$ProteinName == "EEA1", ],
                    aes(x = log2FC, y = -log10(pvalue)), label = "EEA1_HUMAN", color = "green", size = 3, box.padding = 0.5) +
    theme_bw()
  
  ggsave(paste("./postNormalization_VolcanoPlot", paste(comparison, ".pdf", sep = ""), sep = "_"))
})
```